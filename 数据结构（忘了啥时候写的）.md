# 1、排序算法

## 快速排序

![image-20200708085217235](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200708085217235.png)

快速排序采用的是分治法，即选定一个标准，令比该标准大的在一边，比该标准小的放另一边。重复此操作，直至达到要求。

##### 快速排序编程

// 快速排序——填坑法

```c++
#include "pch.h"
#include <iostream>

using namespace std;
template <typename T2>
void Display(T2 *ar, int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << ar[i] << " ";
	}
	cout << "数组输出完毕" << endl;
}

// 1、确定基准数据
// 2、从右边开始比较，
//    若比基准数据大，则right-1；若比基准数据小，则赋值给left，然后从左与基准数据比较
//        若大于基准数据，则赋值给right，，小于基准数据，则left+1  （可加一个循环，判断条件为left《right）
// 3、第二轮将数组分割为两部分
// 注意分割时的界限，以及分割后仅有一个元素时的特殊情况及跳出递归
template <typename T>
void QuickSort(T *arr, int left, int right, int len)
{
	T pivot = arr[left];
	int head = left;   // 考虑分割的界限
	int tail = right;
	bool flag = 0;    // 选择从左还是从右判断

	while (left < right)
	{
		if (!flag)
		{
			if (arr[right] <= pivot)
			{
				arr[left] = arr[right];
				flag = 1;
			}

			else
				right--;
		}
		else
		{
			if (arr[left] > pivot)
			{
				arr[right] = arr[left];
				flag = 0;
			}
			else
				left++;
		}
		if (left == right)
			arr[left] = pivot;
		Display(arr, len);


	}
	// if (arr[head] > arr[head+1])   // 错，当分割后仅存一个元素，无法进行判断
	{
		//if (arr[head] > arr[head])    // 需要加一行这个，上述判断只是将单元数组去掉，，该判断是跳出递归 
		if (head < tail)                  // 或者只用这一行，既能避免单元，
		{
			QuickSort(arr, head, left, len);

			QuickSort(arr, right + 1, tail, len);
		}

	}

}


int main()
{

	double arr[] = { 2.43,10,11,8,1,3,5,7,9 };
	int len = sizeof(arr) / sizeof(arr[0]);
	cout << "排序" << endl;

	QuickSort<double>(arr, 0, len - 1, len);
	cout << "排序完毕" << endl;
	Display<double>(arr, len);
	return 0;

}
```

```c++
// 快速排序
//
#include <iostream>
using namespace std;
void swap1(int& a,int& b)
{
    int tmp =a;
    a = b;
    b = tmp;
}

void quick_sort(int *nums,int left,int right)
{

    // 递归结束条件
    if(left >= right) return;
    cout<<"  22 "<<endl;
    
    int c_left = left;
    int c_right = right;
    int pivot = nums[c_left];
    // 排序
    while(left < right)
    {
        while(left < right && nums[right] >= pivot) right--;
        while(left < right && nums[left] <= pivot) left ++;
        swap1(nums[left] , nums[right]);
    }
    cout<<left <<"right"<<right<<endl;
    swap1(nums[left],nums[c_left]);
    for(int i =0;i<8;i++)
    {
        cout<<nums[i];
    }
    
    quick_sort(nums,c_left,left-1);
    quick_sort(nums,left+1,c_right);

}

int main()
{

    int nums[] = {1,4,2,5,9,7,6,8};
    int left = 0;
    int right = sizeof(nums)/sizeof(nums[0])-1;
    quick_sort(nums,left,right);

}
```



## 归并排序

![image-20200708193332504](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200708193332504.png)

![image-20200708193347565](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200708193347565.png)

归并排序可以分为两大步，即数组分解与归并。更细点的图如下：

![image-20200708204110714](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200708204110714.png)

采用递归的方式进行编程，，从倒数第二层可以看出，再左右分解后，会进行合并的操作，分解合并的操作可采用同样的参数。再往上走，可以看到，依旧有同样的参数可进行分解和归并的操作。因此，可定义函数：

`void Split(int *arr,int *tmp,int left,int right)`;

`void Meger(int *arr,int *tmp,int left,int right)`;

##### 归并排序程序

```c++
#include "pch.h"
#include <iostream>

using namespace std;

void Display(int *ar, int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << ar[i] << " ";
	}
	cout << "数组输出完毕" << endl;
}

// 分解与合并两步操作
void Split(int *arr, int *tmp, int left, int right);
void Merge(int *arr, int *tmp, int left, int right);

void MergeSort(int *arr, int len)
{
	// 分解时以中间处做为界限,
	int middle = (len - 1) / 2;
	// 一个数组会分解为两个，故还需创建一个虚拟数组
	int *tmp = new int[len];

	Split(arr, tmp, 0, len - 1);

	delete[] tmp;
}

// 从最上层开始，每次分解为两个数组，直至最后一层。。然后从最后一层开始，又两两合并，直至合并完成
// 由于
void Split(int *arr, int *tmp, int left, int right)
{
	int middle = (left + right) / 2;
	if (left < right)
	{
		Split(arr, tmp, left, middle);
		Split(arr, tmp, middle + 1, right);
		Merge(arr, tmp, left, right);

	}
}

// 归并的时候，分别对两个数组中的元素进行对比
// 对比完之后，可能还会出现某个数组多余的情形，此时直接加载tmp之后即可
// 操作完之后，由于归并的前提条件是对已排序的数组进行归并，故仍需赋值
void Merge(int *arr, int *tmp, int left, int right)
{
	int middle = (left + right) / 2;
	int left_constant = left;
	int change = middle+1;
	int size_tmp = left;
	while((left<=middle ) && (change <=right))    // 
	{ 
		if (arr[left] < arr[change])
		{
			tmp[size_tmp] = arr[left];
			left++;
			size_tmp++;
		}
		else
		{
			tmp[size_tmp] = arr[change];
			change++;
			size_tmp++;
		}
	}
	while (left <= middle)            // 多余数组直接加在后面
	{
		tmp[size_tmp] = arr[left];
		left++;
		size_tmp++;
	}
	while (change <= right)
	{
		tmp[size_tmp] = arr[change];
		change++;
		size_tmp++;
	}
	for (int i = left_constant; i <= right; i++)
	{
		arr[i] = tmp[i];
	}

}



int main()
{

	int arr[] = { 2,43,10,11,8,2,3,5,7,9 };
	int len = sizeof(arr) / sizeof(arr[0]);
	cout << "排序" << endl;

	MergeSort(arr, len);
	cout << "排序完毕" << endl;
	Display(arr, len);
	return 0;

}
```

# 2、栈

## 顺序栈

##### 顺序栈的程序

1. ##### ![image-20200709110150110](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200709110150110.png)

```c++
// 顺序栈的实现
#include "pch.h"
#include <iostream>
#include <stdio.h
using namespace std;

// 实现过程
// 定义栈底指针、栈顶指针、
template <class T>
class Stack
{
public:
	Stack(int capicity);
	~Stack();
	void Push(T element);
	void Pop(T& element);
	void Display();
	void DestroyStack();
private:
	T *c_base;
	T *c_top;
	int c_capicity;
};

// 构造函数的类外实现:1、创建数组 2、base = top
template <class T>
Stack<T>::Stack(int capicity)
{
	this->c_capicity = capicity;
	c_base = (T*)malloc(sizeof(T)*this->c_capicity);
	if (this->c_base != NULL)
	{
		c_top = c_base;  // 空栈的判断
		cout << "栈创建完毕" << endl;
	}
	else
		cout << "内存分配失败"<<endl;

}

// 析构函数的类外实现：若未销毁栈，则调用析构函数是销毁
template <class T>
Stack<T>::~Stack()
{
	if(this->c_base != NULL)       // 不加这句，若之前已经释放，则会产生重复释放
		free(c_base);
	this->c_base = NULL;
	this->c_top = NULL;
	cout << "析构完毕" << endl;
	
}

// 入栈的类外实现：1、判断栈是否满  2、*top赋值   3、top++
template <class T>
void Stack<T>::Push(T element)
{
	bool flag = 1;     // 判断是否扩增
	if (this->c_top - this->c_base >= this->c_capicity)   // 判断是否满栈
	{
		this->c_base = (T*)realloc(this->c_base, (this->c_capicity+1)*sizeof(T));	  // 扩容

		if (!this->c_base)
		{
			cout << "扩容失败" << endl;
			flag = 0;
		}
			
		else
		{
			this->c_top = this->c_base + this->c_capicity;			
			this->c_capicity++;
			cout << "扩容成功" << endl;
	
		}
	}
	if (flag)
	{
		*(this->c_top) = element;
		this->c_top++;
	}

};

// 出栈的类外实现：1、判断栈是否空  2、top-- 3、*top给赋值   
template <class T>
void Stack<T>::Pop(T& element)
{
	if (this->c_base == this->c_top)
		cout << "栈空" << endl;
	else
	{
		this->c_top--;
		element = *(this->c_top);
		cout << "出栈成功" << endl;
	}
}
// 栈显示的类外实现
template <class T>
void Stack<T>::Display()
{
	T *tmp = this->c_base;
	while (tmp != this->c_top)
	{
		cout << *tmp;
		tmp++;
	}
	cout << endl;
}

// 类外实现销毁
template <class T>
void Stack<T>::DestroyStack()
{
	free(this->c_base);
	this->c_base = NULL;
	this->c_top = NULL;
	cout << "销毁完成" << endl;

}

int main()
{
	Stack<int> s(2);
	s.Push(19);
	s.Display();
	s.Push(11);
	s.Display();
	s.Push(13);
	s.Display();
	int e;
	s.Pop(e);
	cout << e << endl;
	s.DestroyStack();
	return 0;

}
```

# 3、链表

## 单向链表

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190424210635498.png)

![img](https://img-blog.csdnimg.cn/20190424210658579.png)

##### 单向链表的程序

1. ##### 

（创建、插入、删除、显示、反转、）

```c++
// 单向链表的实现
#include "pch.h"
#include <iostream>
#include <stdio.h>
using namespace std;

// 实现过程：
// 结点的定义:一个结点包含数据域和指针域
template <class T>
class Node
{
public:
	T c_data;
	Node *c_next;        // 注意2：指针是指向结点的
};

template <class T>
class Link
{
public:
	Link();
	~Link();
	void InsertLink_head(T element);
	void InsertLink_tail(T element);
	void DisplayLink();
	void DeleteLink(int num);  // 删除第n个结点，头结点为0
	void Invert(Node<T> *pfront, Node<T> *pback);
	void InvertLink();
	void Concatenate(Link<T> &l);
private:
	Node<T> *c_pfirst;
};

// 链表构造函数的类外实现：1、创建头结点，令头指针指向头结点
//                         2、对头结点赋值，头结点数据域为结点长度（不包含头）
template <class T>
Link<T>::Link()
{
	this->c_pfirst = new Node<T>;    // 注意1：new时需要加模板参数列表
	if (!this->c_pfirst)
		cout << "分配失败" << endl;
	else
	{
		this->c_pfirst->c_next = NULL;
		this->c_pfirst->c_data = 0;
		cout << "构造完成" << endl;
	}
};

// 链表析构函数的类外实现
template <class T>
Link<T>:: ~Link()
{
	if (!this->c_pfirst)
	{
		delete this->c_pfirst;
		this->c_pfirst = NULL;
	}
	cout << "析构完成" << endl;
}

// 头插法的类外实现：每进一个新结点，均放在头结点后。
// 新结点的next指向原头结点指向的,头结点的next指向新结点，；
// 头结点的数据域+1
template <class T>
void Link<T>::InsertLink_head(T element)
{
	Node<T> *ptmp = new Node<T>;
	if (!ptmp)
		cout << "新建结点失败" << endl;
	else
	{
		ptmp->c_next = this->c_pfirst->c_next;
			this->c_pfirst->c_next = ptmp;

			ptmp->c_data = element;

			this->c_pfirst->c_data += 1;

			cout << "头插法插入完成" << endl;
	}

	
};

// 尾插法的类外实现：从头指针开始，循环遍历，找到最后的结点，在最后结点进行插入操作
// 同样，先将最后的next指向新结点，再将新结点next指向null
template <class T>
void Link<T>::InsertLink_tail(T element)
{
	Node<T> *ptmp = new Node<T>;
	if (!ptmp)
		cout << "新建结点失败" << endl;
	else
	{
		Node<T> *pchange = this->c_pfirst;
		
		ptmp->c_data = element;

		
		while (pchange->c_next)
		{
			// pchange++;            // 注意3：链表指针不能直接加
			pchange = pchange->c_next;
		}
		ptmp->c_next = pchange->c_next;
		pchange->c_next = ptmp;

		this->c_pfirst->c_data += 1;
		cout << "尾插法完成" << endl;
	}
	
};

// 显示链表的类外实现:
template <class T>
void Link<T> ::DisplayLink()
{
	Node<T> *pchange = this->c_pfirst;
	while (pchange->c_next)
	{
		pchange = pchange->c_next;
		cout << pchange->c_data<<" ";
	}
	cout << endl;
};

// 删除第n个结点，头结点为0
// 删除时，将n-1的next指向n+1.。然后delete n就行
template <class T>
void Link<T>::DeleteLink(int num)
{
	if (num > this->c_pfirst->c_data)
		cout << "不存在第" << num << "个结点" << endl;
	else
	{
		Node<T> *pchange = this->c_pfirst;
		Node<T> *pdelete = NULL;
		for (int i = 1; i < num; i++)
		{
			pchange = pchange->c_next;
		}
		pdelete = pchange->c_next;
		pchange->c_next = pdelete->c_next;
		delete pdelete;
		this->c_pfirst->c_data -= 1;
	}
	

};

// 将链表进行反转：正常的思路就是从头开始找到尾之后，以此修改next
// 但在找栈尾的同时，可直接进行反转操作。
template <class T> 
void Link<T> ::Invert(Node<T> *pfront, Node<T> *pback)
{
	if (pfront == this->c_pfirst->c_next)      // 注意4: 头指针的处理（仅在第一层迭代进行处理）
		pfront->c_next = NULL;
	if (pback)
	{	
		Node<T> *tmp = pback->c_next;

		pback->c_next = pfront;
		pfront = pback;
		pback = tmp;
		Invert(pfront, pback);
	}
	else                                // 注意5 若不加else，则每层都会进行以下操作
		                               // （迭代时除注意迭代退出的条件，还需注意层层迭代）
	{
		this->c_pfirst->c_next = pfront;   // 只在最后一层迭代进行操作

	}
	cout << "反转完成" << endl;
};
template <class T>
void Link<T>::InvertLink()
{
	Invert(this->c_pfirst->c_next, this->c_pfirst->c_next->c_next);
};


template <class T>
void Concatenate(Link<T> &l);
int main()
{
	Link<int> l;
	l.InsertLink_head(6);
	l.DisplayLink();
	l.InsertLink_head(12);
	l.DisplayLink();
	l.InsertLink_tail(14);
	l.DisplayLink();
	l.InsertLink_head(12);
	l.DisplayLink();
	l.DeleteLink(5);
	l.DisplayLink();
	l.InvertLink();
	l.DisplayLink();

	return 0;

}
```

## 单向循环链表

![image-20200709210056511](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200709210056511.png)

##### 循环链表的程序

具体见上述代码，下属代码在单向链表基础上修改

this->c_pfirst->c_next = this->c_pfirst;    // **需要改的点1：循环链表，头结点指向本身**（构造函数中）

​	while (pchange->c_next != this->c_pfirst)  // **需要改的点2：判定停止条件**（显示函数中）

if (num > this->c_pfirst->c_data)
		cout << "不存在第" << num << "个结点" << endl; 需要改的点3：**无需判断是否超出范围，只需判断是否空**（删除节点中，不需要此行代码）

if (num % 3)                       // **需要改的点4：循环链表不算头结点**
			num = num % 3;
		else
			num = 3;

## 双向链表

![image-20200709213246984](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200709213246984.png)

```c++
// 双向循环链表的实现
#include "pch.h"
#include <iostream>
#include <stdio.h>
using namespace std;

// 实现过程：
// 结点的定义:一个结点包含数据域和前后指针域指针域
template <class T>
class Node
{
public:
	T c_data;
	Node *c_next;       
	Node *c_front;
};

template <class T>
class Link
{
public:
	Link();
	~Link();
	void InsertLink_head(T element);
	void DisplayLink();
	void DeleteLink(int num);  // 删除第n个结点，头结点为0

private:
	Node<T> *c_pfirst;
};

// 循环双向链表构造函数的类外实现：1、创建头结点，令头指针指向头结点
//								   2、对头结点赋值，头结点数据域为结点长度（不包含头）
//							       3、next指向自己，，front也指向自己
template <class T>
Link<T>::Link()
{
	this->c_pfirst = new Node<T>;
	if (!this->c_pfirst)
		cout << "创建结点失败" << endl;
	else
	{
		this->c_pfirst->c_data = 0;
		this->c_pfirst->c_front = this->c_pfirst;
		this->c_pfirst->c_next = this->c_pfirst;
		cout << "创建结点成功" << endl;
	}
};

// 循环链表析构函数的类外实现
template <class T>
Link<T>:: ~Link()
{
	if (!this->c_pfirst)
	{
		delete this->c_pfirst;
		this->c_pfirst = NULL;
	}
	cout << "析构完成" << endl;
}

// 头插法的类外实现：每进一个新结点，均放在头结点后。
// 新结点的next指向原头结点指向的,头结点的next指向新结点；
// 新结点的front指向头指针，新结点被指向需要分类讨论
//（若为空链表，则令头结点的front指向新结点即可；若不为空结点，则需令头结点的next->front指向新结点。）
// 头结点的数据域+1
template <class T>
void Link<T>::InsertLink_head(T element)
{
	Node<T> *ptmp = new Node<T>;
	if (!ptmp)
		cout << "新建结点失败" << endl;
	else
	{
		ptmp->c_data = element;
		this->c_pfirst->c_data += 1;

		ptmp->c_next = this->c_pfirst->c_next;
		this->c_pfirst->c_next = ptmp;
		
		ptmp->c_front = this->c_pfirst;
		if (this->c_pfirst->c_next)
			this->c_pfirst->c_next->c_front = ptmp;
		else
			this->c_pfirst->c_front = ptmp;	
	}

};

// 显示链表的类外实现:
template <class T>
void Link<T> ::DisplayLink()
{
	Node<T> *pchange = this->c_pfirst;
	while (pchange->c_next != this->c_pfirst)  
	{
		pchange = pchange->c_next;
		cout << pchange->c_data<<" ";
	}
	cout << endl;
};

// 删除第n个结点，头结点为0
// 和循环链表删除过程类似，无需判断是否超过界限。只需要对num处理
// 删除时分为删next和front。。
// 删next时，找到删除结点的前一个，令next = next->next即可
// 删front时，则需令next->next->front = n-1个结点
template <class T>
void Link<T>::DeleteLink(int num)    
{
	int n = num % (this->c_pfirst->c_data);
	if (!n)
		n = this->c_pfirst->c_data;

	Node<T> *pchange = this->c_pfirst;
	for (int i = 1; i < n; i++)
	{
		pchange = pchange->c_next;
	}
	
	pchange->c_next = pchange->c_next->c_next;
	
	pchange->c_next->c_next->c_front = pchange;
	
	this->c_pfirst->c_data -= 1;
	cout << "删除结点" << endl;

};


int main()
{
	Link<int> l;
	l.InsertLink_head(12);
	l.InsertLink_head(34);
	l.DisplayLink();
	l.InsertLink_head(1);
	l.InsertLink_head(37);

	l.DisplayLink();
	l.DeleteLink(3);
	l.DisplayLink();
	l.DeleteLink(3);
	l.DisplayLink();
	return 0;

}
```

## 基数排序

<img src="C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200712094251615.png" alt="image-20200712094251615" style="zoom:80%;" />

![image-20200712094329241](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200712094329241.png)



![image-20200712094355710](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200712094355710.png)

![image-20200712094414037](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200712094414037.png)

```
#include "pch.h"
#include <iostream>
#include <list>
using namespace std;
// 基数排序

int maxdigit(int data[], int n)
{
	int d = 1;
	int p = 10;
	for (int i = 0; i < n; i++)
	{
		while (data[i]>p)
		{
			p *= 10;
			d++;
		}
	}
	return d;
};
void radisort(int data[], int n)
{
	int d = maxdigit(data, n);
	list<int> l[10];


	for (int i = 1,factor =1; i <= d;factor*=10,i++)
	{
		// 第一步：将个/十/白位数的元素依次放到对应的链表中
		for (int j = 0; j < n; j++)
		{
			l[data[j]/factor % 10].push_back(data[j]);      // 注意1：取个、十、百地方法
		}
	
		// 第二步：依次从链表中取出，再放回数组中
		for (int k = 0,m=0; k < 10; k++)
		{
			while (!l[k].empty())
			{
				data[m++] = l[k].front();                    // 注意2：取得是元素，不是指针
				l[k].pop_front();
			}
				
		}
		for (int n = 0; n < 6; n++)
		{
			cout << "基数排序中"<<data[n] << " ";
		}
		cout << endl;
	}


};
int main()
{
	int a[] = { 13,15,11,10,22,88};
	radisort(a, 6);
	for (int i=0; i < 6; i++)
	{
		cout << a[i] << " ";
	}

}
```



## 栈队列

![image-20200710170001369](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200710170001369.png)

```c++
// 链队列的实现
#include "pch.h"
#include <iostream>
#include <stdio.h>
using namespace std;

template <class T>
class Node
{
public:
	T data;
	Node<T> *pnext;
};

// 队列需要定义头指针和尾指针保证便于入队和出队
template <class T>
class Queue
{
public:
	Queue();
	~Queue();
	void InsertQueue(T element);
	void DisplayQueue();
	void DeleteQueue();

private:
	Node<T> *pFirstl;
	Node<T> *pLast;
};

// 队列构造函数的类外实现
// 1、创建头结点，令头指针和尾指针均指向其
template <class T>
Queue<T>::Queue()
{
	this->pFirstl = new Node<T>;
	if (!this->pFirstl)
		cout << "创建头结点失败" << endl;
	else
	{
		this->pLast = this->pFirstl;
		

		this->pFirstl->pnext = NULL;
		this->pFirstl->data = 0;
		cout << "头结点创建完毕" << endl;
	}

};

template <class T>
Queue<T> :: ~Queue()
{
	if (this->pFirstl)      // 防止重复释放
	{
		delete this->pFirstl;
		this->pFirstl = NULL;
	}
	cout << "析构完成" << endl;
};

// 队列插入：由于队列是先入先出的原则，故其为尾插法
// 由于队尾指针已知。故新结点next=队尾指针next；；队尾指针next=新结点。。队尾指针=新结点
template <class T>
void Queue<T> :: InsertQueue(T element)
{
	Node<T> *newnode = new Node<T>;
	if (!newnode)
		cout << "新结点创建失败" << endl;
	else
	{
		newnode->pnext = this->pLast->pnext;
		this->pLast->pnext = newnode;

		this->pLast = newnode;
	
		newnode->data = element;
	
		this->pFirstl->data += 1;
		cout << "新结点创建成功" << endl;
	}

};

// 队列显示的类外实现
// 循环遍历，
template <class T>
void Queue<T> ::DisplayQueue()
{
	Node<T> *pchange = this->pFirstl;
	if (!pchange)
		cout << "链表尾空" << endl;
	cout << "链表为" << endl;
	while (pchange->pnext != NULL)
	{
		pchange = pchange->pnext;
		cout << pchange->data<<" ";
	}
	cout << endl;
};

// 结点的删除
// 删除是从头部删除，头部制作的next = 删除结点的next。delete
template <class T>
void Queue<T> :: DeleteQueue()
{
	Node<T> *deletenode = this->pFirstl->pnext;

	this->pFirstl->pnext = this->pFirstl->pnext->pnext;
	
	delete deletenode;
	deletenode = NULL;
	// this->pFirstl->pnext = NULL;     // this->pFirstl不是删除的节点
	
	this->pFirstl->data -= 1;

};

int main()
{
	Queue<int> q;
	q.InsertQueue(12);
	q.InsertQueue(3);
	q.InsertQueue(15);
	q.DisplayQueue();
	q.DeleteQueue();
	q.DisplayQueue();
	q.InsertQueue(1);
	q.DisplayQueue();
	q.DeleteQueue();
	q.DisplayQueue();

	return 0;

}

```

```c++
## 链表迭代器

#include "pch.h"
#include <iostream>
#include <list>

using namespace std;

int main()
{
	list<int> l;
	l.push_front(13);
	l.push_front(100);
	l.push_front(1);

	list<int> l1;
	l1.push_back(1111);
	l1.push_back(2222);
	l1.push_back(3333);
	l.insert(l.begin(), 10);   // 第一个参数是迭代器，插在迭代器的初始位置
	l.insert(l.end(), 111);    // 插在最后
	l.insert(l.begin(), 2,11); // 插入2个11
	l.insert(l.begin(),l1.begin(), l1.end());  // 将l1的元素插入l中
	for (list<int> ::iterator it = l.begin(); it != l.end(); it++)
	{
		cout << (*it) << endl;
	}

}
```

# 4、树

1、数组的优缺点:优：可进行二分查找，查找速度很快（2^20 = 100万，20次可查找100万数据）。但其插入删除操作不方便。

2、链表优缺点：链表不可进行二分查找。。但其插入删除操作灵活。

3、树——数组的优点+链表的优点

4、树的术语：

结点        度        叶结点        父结点        子结点        兄弟结点        树的度        树的高度（深度）

## 二叉树

![image-20200711101327599](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200711101327599.png)

##### 链表表示上述二叉树

前序排列、中序排列、后序排列（差别在于中间结点位于第几个）

```c++
#include "pch.h"
#include <iostream>
#include <queue>
using namespace std;

// 用链表表示树

// 首先定义结点：树的结点最多有两个指针，分别指向左子结点和右子结点
template <class T>
class TreeNode
{
public:
	TreeNode()
	{
		this->c_pleft = NULL;
		this->c_pright = NULL;
	}

	T data;
	TreeNode<T> *c_pleft;
	TreeNode<T> *c_pright;

};

// 树类需要定义根结点（类似链表首元结点）
template <class T>
class Tree
{
public:
	void InOrder(TreeNode<T> *current);   // 中序遍历
	void PostOrder(TreeNode<T> *current);
	void PreOrder(TreeNode<T> *current);
	void LayerOrder(TreeNode<T> *current);
	TreeNode<T> *root;
};

// 中序遍历:A/B*C-D+E
template <class T>
void Tree<T> ::InOrder(TreeNode<T> *current)
{
	if (current)
	{
		InOrder(current->c_pleft);
		cout << current->data << endl;
		InOrder(current->c_pright);
	}
};

// 前序遍历:+-*/abcde
template <class T>
void Tree<T> ::PreOrder(TreeNode<T> *current)
{
	if (current)
	{
		cout << current->data << endl;
		PreOrder(current->c_pleft);
		PreOrder(current->c_pright);
	}
};

// 后序遍历:AB/C*D-E+
template <class T>
void Tree<T> ::PostOrder(TreeNode<T> *current)
{
	if (current)
	{
		PostOrder(current->c_pleft);
		PostOrder(current->c_pright);
		cout << current->data << endl;

	}

};

// 层序排列
// 一层一层取出元素，即第二层：左，右；第三层：左、右、左、右；以此类推
// 可利用队列先入先出的原则进行。
template <class T>
void Tree<T> ::LayerOrder(TreeNode<T> *current)
{
	queue <TreeNode<T> *> q;
	cout << "cengxu" << endl;
	while (current)
	{
		cout << (*current).data << " ";

		if (current->c_pleft) q.push(current->c_pleft);
		if (current->c_pright) q.push(current->c_pright);
		if (q.empty()) return;      // 注意：此行不可缺，，

		current = q.front();       // 空队列无法取front
		q.pop();

	}
	

};

int main()
{

	TreeNode<char> add, jian, cheng, chu, a, b, c, d, e;
	add.data = '+';
	jian.data = '-';
	cheng.data = '*';
	chu.data = '/';
	a.data = 'A';
	b.data = 'B';
	c.data = 'C';
	d.data = 'D';
	e.data = 'E';

	Tree<char> t;
	t.root = &add;
	add.c_pleft = &jian;
	add.c_pright = &e;

	jian.c_pleft = &cheng;
	jian.c_pright = &d;

	cheng.c_pleft = &chu;
	cheng.c_pright = &c;

	chu.c_pleft = &a;
	chu.c_pright = &b;

	t.InOrder(t.root);
	t.PreOrder(t.root);
	t.PostOrder(t.root);
	t.LayerOrder(t.root);
}
```

## 二叉查找树

1、BST（二叉查找树）：Binary Search Tree

2、性质：a、每一个元素都有一个键值，且不允许重复。

​				  b、左子树键值小于根节点键值；右子树键值大于根节点键值；

​                  c、左右子树均为二叉查找树。

代码不确定

```c++
// 二叉查找树

#include "pch.h"
#include<iostream>

using namespace std;

class BstTreeNode
{
public:
	friend class BstTree;

private:
	int c_data;
	BstTreeNode *c_pleft;
	BstTreeNode *c_pright;
};

class BstTree
{
public:
	BstTree()
	{
		this->c_proot = NULL;
	}
	bool InsertNode(int element);
	void DisplayNode(BstTreeNode *current);
	BstTreeNode *c_proot;
};

// 插入结点
bool BstTree::InsertNode(int element)
{
	BstTreeNode *p = this->c_proot;
	BstTreeNode *q = p;

	// 找到准备插入的地方
	while (q)
	{
		p = q;
		if (element > p->c_data) q = p->c_pright;
		else if (element < p->c_data)  q = p->c_pleft;
		else  return 0;
	}
	// 插入
	// 新建准备插入的结点
	q = new BstTreeNode;   // q的地址发生了变化，在下面需要重新连接
	q->c_data = element;
	q->c_pleft = NULL;
	q->c_pright = NULL;
	
	// 找到插入的位置
	if (!this->c_proot)  // 可能为空树
	{
		this->c_proot = q;
		cout << "根结点创建完毕" << endl;
	}
	else if (element < p->c_data) p->c_pleft = q;
	else p->c_pright = q;
	
	cout << "结点插入成功" << endl;
	return 1;

};


void BstTree::DisplayNode(BstTreeNode *current)
{
	if (current)
	{			
		cout << current->c_data << " ";

		if (current->c_pleft) DisplayNode(current->c_pleft);		
	
		if (current->c_pright) DisplayNode(current->c_pright);		
	
	}

};

int main()
{
	BstTree t;

	t.InsertNode(1);
	t.InsertNode(2);
	t.InsertNode(31);
	t.InsertNode(4);
	t.InsertNode(14);
	t.InsertNode(42);
	
	t.DisplayNode(t.c_proot);


​	
}   
```

##         红黑树

红黑树特征：节点都有颜色。插入删除时遵守红黑原则

红黑规则：

1、每一个节点不是红色就是黑色

2、根总是黑色的

3、若节点是红色，则子节点必须黑色（不能连续两个红色）

4、从根到叶节点的每条路径，必须包含相同数目的黑色节点。

修正方法：1、改变节点颜色；2、旋转

# 5、堆





![image-20200713101017539](C:\Users\a\AppData\Roaming\Typora\typora-user-images\image-20200713101017539.png)

​       堆是**完全二叉树**，除了树的最后一层节点不需要是满的，其它的每一层从左到右都是满的。注意下面两种情况，第二种最后一层从左到右中间有断隔，那么也是不完全二叉树。

​       堆排序：将数组元素依次放入堆，然后再取出即可完成排序

##### 堆及堆排序代码

```c++
#include "pch.h"
#include <iostream>

using namespace std;

class MaxHeap
{
public:

	MaxHeap(int mx);     // 若为默认参数，不能同时出现在声明和定义中
	~MaxHeap();
	bool IsEmpty();
	void InsertNode(int ele);   // 插入新节点
	void Upmoving(int ele,int index);   // 向上渗透
	bool OddorEven(int index);
	void swap1(int& a, int& b);

	void Insert_noiter(int ele);
	void Upmoving_noiter(int index);   // 向上渗透

	void display();
	void DeleteNode(int &e);   // 删除根节点
	void downmoving(int father_index);

private:
	int c_maxsize;
	int c_currentsize;
	int *heaparray;
};

MaxHeap::MaxHeap(int mx = 10)
{
	if (mx < 1) throw "maxszie must > 0";
	
	this->c_maxsize = mx;
	this->c_currentsize = 0;
	this->heaparray = new int[this->c_maxsize];
}
MaxHeap :: ~MaxHeap()
{
	if (heaparray)
	{
		delete[] heaparray;
		heaparray = NULL;
	}
	cout << "析构成功" << endl;
}
bool MaxHeap::IsEmpty()
{
	if (this->c_currentsize == 0) return 1;
	else return 0;
};

bool MaxHeap::OddorEven(int index)  // 0为偶数、1为奇数
{
	bool flag = (index) % 2;
	return flag;  
}; 

void MaxHeap :: swap1(int& a, int& b)
{
	int temp;
	temp = a;
	a = b;
	b = temp;
}
void MaxHeap::Upmoving(int ele,int index)
{
	if (this->c_currentsize >= this->c_maxsize)
		cout << "堆已满" << endl;
	else
	{			

		// 如果为空，则无父节点，直接赋值即可
		if (this->c_currentsize == 0)
		{
			heaparray[this->c_currentsize] = ele;
			this->c_currentsize++;
			return ;
		}

		// 若不为空。则需：1、查找父结点位置 2、比较大小  3、交换递归或者结束
		int father_index = (index - OddorEven(index)) / 2;
		if ((heaparray[father_index - 1] > heaparray[index - 1]) || (index == 1))  // 迭代结束条件
		{ 
			this->c_currentsize++;
		}
		
		else if (heaparray[father_index - 1] < heaparray[index - 1])
		{
			swap1(heaparray[father_index - 1], heaparray[index - 1]);
			Upmoving(ele, father_index);

		}
		else cout << "数字重复" << endl;

	}
}

void MaxHeap :: InsertNode(int ele)
{
	heaparray[this->c_currentsize] = ele;      // 注：此处不能用this->c_currentsize 
	Upmoving(ele,this->c_currentsize+1);
}


void MaxHeap :: display()
{
	for (int i = 0; i < this->c_currentsize; i++)
		cout << heaparray[i] << " ";
	cout << endl;
}
void MaxHeap::Insert_noiter(int ele)
{
	heaparray[this->c_currentsize] = ele;
	Upmoving_noiter(this->c_currentsize + 1);
}

// 与迭代类似：1、找到父结点  2、比较交换  
void MaxHeap::Upmoving_noiter(int index)   // 向上渗透
{
	int father_index = (index - OddorEven(index)) / 2;

	while ((father_index > 0) && (heaparray[father_index-1]< heaparray[index-1]))
	{
		swap1(heaparray[father_index-1], heaparray[index-1]);
		index = father_index;
		father_index = (index - OddorEven(index)) / 2;
	}
	this->c_currentsize++;
}
// 向下渗透：1、判断有几个子结点（若只有左节点无右节点，则一定处于最后一层）
//           2、判断左右节点大小，并比较交换
void MaxHeap::downmoving(int father_index)
{
	int right_index = 2 * father_index + 1;
	int left_index = 2 * father_index;
	int lager_index;
	while (right_index <= this->c_currentsize)
	{
		// 判断左右节点大小
		if (heaparray[right_index-1] > heaparray[left_index-1])
		{
			lager_index = right_index;
		}
		else if (heaparray[right_index-1] < heaparray[left_index-1])
		{
			lager_index = left_index;
		}

		// 若小于则交换
		if (heaparray[lager_index-1] > heaparray[father_index-1])
		{
			swap1(heaparray[lager_index-1], heaparray[father_index-1]);
			father_index = lager_index;
		}
		else
			break;
		right_index = 2 * father_index + 1;
		left_index = 2 * father_index;
	}

	// 若只有左节点，则直接判断即可
	if ((left_index <= this->c_currentsize) && (right_index > this->c_currentsize))
	{
		if (heaparray[left_index-1]>heaparray[father_index-1])
		{
			swap1(heaparray[lager_index-1], heaparray[father_index-1]);
		}
	}
}
void MaxHeap :: DeleteNode(int &e)   // 删除根节点
{
	e = heaparray[0];
	heaparray[0] = heaparray[this->c_currentsize-1];
	this->c_currentsize--;
	downmoving(1);

}
int main()
{
	MaxHeap m(10);
	m.IsEmpty();
	m.InsertNode(1);
	m.InsertNode(11);
	m.InsertNode(10);
	m.InsertNode(110);
	m.InsertNode(101);
	// m.InsertNode(111);

	m.Insert_noiter(111);
	m.display();
	// 堆排序
	int a[6];
	int e;
	for (int i = 0; i < 6; i++)
	{
		m.DeleteNode(e);
		a[i] = e;
		cout << e << " " << endl;
	}

	return 0;
}

```

# HashMap



```
#include "pch.h"
#include <iostream>
#include <unordered_map>
#include <string>

using namespace std;

class Pair
{
	friend class HashMap;

	Pair(int value, string key):c_value(value), c_key(key) {};
	Pair() {};

private:
	int c_value;
	string c_key;
};

class HashMap
{
public:
	HashMap(int size)  
	{
		this->c_currentsize = 0;
		c_arr = new Pair[size];
	};

	void Put(const string& k, const int& v)
	{
		int pos = Hash(k); 
		Pair p(v, k);
		c_arr[pos] = p;
		this->c_currentsize ++ ;
	}
	
	int Get(const string& k)
	{
		int pos = Hash(k);
		if (c_arr[pos].c_key == k)
			return c_arr[pos].c_value;
		return -1;
	}
	unsigned Hash(const string& k) 
	{
		unsigned int hashval = 0;
		const char *keyp = reinterpret_cast<const char *>(&k);   
		for (size_t i = 0; i < sizeof(string); i++)
		{
			hashval = 37 * hashval + keyp[i];
		}
		
		hashval %= 11;
		return hashval;
	}

private:
	Pair *c_arr;
	int c_currentsize;
};
int main()
{

	HashMap hm(11);
	hm.Put("lewao",11);
	hm.Put("ShuAyuan", 14);
	cout<< hm.Hash("ShuAyuan");


​	

	return 0;

}
```

